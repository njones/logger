package main

import (
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"os/exec"
	"regexp"
	"strings"
	"sync"
	"text/template"
	"time"
)

// gen.go generates the logger functions

var genFileIn = "logger_generated.go"
var genFileOut = "logger.go"

func minus(a, b int) int { return a - b }

func main() {
	lf, err := os.Create(genFileIn)
	if err != nil {
		log.Fatal(err)
	}
	defer func() {
		cmd := exec.Command("go", "fmt", genFileIn)
		err := cmd.Run()
		if err != nil {
			log.Fatal(err)
		}
		log.Println("go code formatted...")
	}()
	defer lf.Close()

	fset := token.NewFileSet() // positions are relative to fset
	f, err := parser.ParseFile(fset, genFileOut, nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}

	// Create an ast.CommentMap from the ast.File's comments.
	// This helps keeping the association between comments
	// and AST nodes.
	cmap := ast.NewCommentMap(fset, f, f.Comments)

	internal := struct {
		Timestamp        time.Time
		LogLevels        map[string]uint
		LogLevelsShort   map[string]uint
		LogColors        map[string]string
		LogHasESCColors  map[string]string
		LogStdCompatible map[string]string
		LogAlias         map[string]bool
	}{
		Timestamp:        time.Now().UTC(),
		LogLevels:        make(map[string]uint),
		LogLevelsShort:   make(map[string]uint),
		LogColors:        make(map[string]string),
		LogHasESCColors:  make(map[string]string),
		LogStdCompatible: make(map[string]string),
		LogAlias:         make(map[string]bool),
	}

	rx := regexp.MustCompile("//\\s+`(.*)`")

	for kk, vv := range cmap {

		if val, ok := kk.(*ast.ValueSpec); ok {

			foundComment := rx.FindAllStringSubmatch(vv[0].List[0].Text, 1)
			if len(foundComment) > 0 && len(foundComment[0]) > 1 {
				commentTag := foundComment[0][1]
				keyvals := strings.Split(commentTag, " ")
				for _, kv := range keyvals {
					kvs := strings.Split(kv, ":")
					k := kvs[0]
					v := strings.Trim(kvs[1], `"`)

					if k == "gen.color" {
						internal.LogColors[val.Names[0].Name] = v
					}
				}
			}
		}

		if val, ok := kk.(*ast.Field); ok {

			foundComment := rx.FindAllStringSubmatch(vv[0].List[0].Text, 1)
			if len(foundComment) > 0 && len(foundComment[0]) > 1 {
				var wait sync.WaitGroup

				colorCh := make(chan string, 1)
				commentTag := foundComment[0][1]
				keyvals := strings.Split(commentTag, " ")
				for _, kv := range keyvals {
					kvs := strings.Split(kv, ":")
					k := strings.TrimSpace(kvs[0])
					v := strings.Trim(strings.TrimSpace(kvs[1]), `"`)

					if k == "gen.show" {
						internal.LogHasESCColors[val.Names[0].Name] = v
						colorCh <- v
					}

					if k == "gen.stdlog.compat" {
						vs := strings.Split(v, ",")
						if len(vs) > 1 {
							for i := 1; i < len(vs); i++ {
								wait.Add(1)
								// this is in a go routine so it can come before or after
								go func(j int) {
									wait.Done()
									internal.LogHasESCColors[vs[j]] = <-colorCh
								}(i)
							}
						}
					}
				}
				wait.Wait()
			}
		}

		if val, ok := kk.(*ast.GenDecl); ok {

			if val.Tok == token.TYPE {
				if val.Specs[0].(*ast.TypeSpec).Name.Name == "level" {
					for k3, v3 := range val.Specs[0].(*ast.TypeSpec).Type.(*ast.StructType).Fields.List {

						var short, alias string
						foundComment := rx.FindAllStringSubmatch(v3.Comment.List[0].Text, 1)
						if len(foundComment) > 0 && len(foundComment[0]) > 1 {
							commentTag := foundComment[0][1]
							keyvals := strings.Split(commentTag, " ")
							for _, kv := range keyvals {
								kvs := strings.Split(kv, ":")
								k := strings.TrimSpace(kvs[0])
								v := strings.Trim(strings.TrimSpace(kvs[1]), `"`)

								if k == "gen.short" {
									short = v
								}

								if k == "gen.alias" {
									alias = v
								}

								if k == "gen.stdlog.compat" {
									vs := strings.Split(v, ",")
									if len(vs) == 1 {
										internal.LogStdCompatible[v3.Names[0].Name] = vs[0]
									} else {
										for i := 1; i < len(vs); i++ {
											internal.LogStdCompatible[vs[i]] = vs[0]
										}
									}
								}
							}
						}

						internal.LogLevels[v3.Names[0].Name] = 1 << uint(k3)
						internal.LogLevelsShort[short] = 1 << uint(k3)

						if alias != "" {
							internal.LogLevels[alias] = 1 << uint(k3)
							internal.LogLevelsShort[short] = 1 << uint(k3)
							internal.LogAlias[alias] = true
						}
					}
				}
			}
		}
	}

	err = packageTemplate.Execute(lf, internal)
	log.Println("Done:", err)
}

var funcMap = template.FuncMap{"minus": minus}
var packageTemplate = template.Must(template.New("").Funcs(funcMap).Parse(`// go generate
// GENERATED BY THE COMMAND ABOVE; DO NOT EDIT THIS FILE
// ~~ This file is not generated by hand ~~
// ~~ generated on: {{ .Timestamp }} ~~

package logger

import (
	"net/http"
)

// String is the string representation of the color
func (lc LogColor) String() string {
	switch lc {
	{{-  range $key, $value := .LogColors }}
	case {{ $key }}:
		return "{{ $key }}"
	{{- end }}
	}

	return "unknown"
}

// ToESCColor is the escape string representation of the color int32 number
func (lc LogColor) ToESCColor() string {
	switch lc {
	{{-  range $key, $value := .LogColors }}
	case {{ $key }}:
		return "{{ $value }}"
	{{- end }}
	}

	return "0"
}

// Level returns the log level used
func Level() (lvl level) {
{{-  range $key, $value := .LogLevels }}
{{- if ne true (index $.LogAlias $key) }}
	lvl.{{ $key }} = {{ $value }}
{{- end }}
{{- end }}
	return lvl
}

// String is the string representation of the log level
func (ll LogLevel) String() string {
	switch ll {
	{{-  range $key, $value := .LogLevels }}
	{{- if ne true (index $.LogAlias $key) }}
	case {{ $value }}:
		return "{{ $key }}"
	{{- end }}
	{{- end }}
	}

	return "unknown"
}

// StringWithColon is the string representation of the log level with trailing colon
func (ll LogLevel) StringWithColon() string {
	switch ll {
	{{-  range $key, $value := .LogLevels }}
	{{- if ne true (index $.LogAlias $key) }}
	case {{ $value }}:
		return "{{ $key }}:"
	{{- end }}
	{{- end }}
	}

	return "unknown"
}

// Short is the short three letter abbreviation of the log level
func (ll LogLevel) Short() string {
	switch ll {
	{{-  range $key, $value := .LogLevelsShort }}
	{{- if ne true (index $.LogAlias $key) }}
	case {{ $value }}:
		return "{{ $key }}"
	{{- end }}
	{{- end }}
	}

	return "unknown"
}

// Logger is the main interface that is presented as a logger
type Logger interface {
	Color(LogColor) Logger
	NoColor() Logger
	Field(string, interface{}) Logger
	Fields(...keyValue) Logger
	HTTPMiddleware(next http.Handler) http.Handler
	OnErr(error) Logger
	Suppress()
	UnSuppress()
{{ range $key, $value := .LogLevels }}
{{- if eq "true" (index $.LogStdCompatible $key)}}
    {{ $key }}(...interface{})
	{{ $key }}f(string, ...interface{})
	{{ $key }}ln(...interface{})
{{- else }}
	{{ $key }}(...interface{})
	{{ $key }}f(string, ...interface{})
{{- end }}
{{- end }}
}
{{ range $key, $value := .LogLevels }}
{{- if eq "true" (index $.LogStdCompatible $key)}}
// {{ $key }} is the generated logger function to satisfy the interface
func (l *logger) {{ $key }}(iface ...interface{}) {
	l.l.Lock() // locks in the color change
	switch l.color {
	case "":
		l.color = {{ index $.LogHasESCColors $key }}.ToESCColor()
	}
	l.print({{ $value }}, iface...)
	l.l.Unlock()
}

// {{ $key }}f is the generated logger function to satisfy the interface
func (l *logger) {{ $key }}f(fmt string, iface ...interface{}) {
	l.l.Lock() // locks in the color change
	switch l.color {
	case "":
		l.color = {{ index $.LogHasESCColors $key }}.ToESCColor()
	}
	l.printf({{ $value }}, fmt, iface...)
	l.l.Unlock()
}

// {{ $key }}ln is the generated logger function to satisfy the interface
func (l *logger) {{ $key }}ln(iface ...interface{}) {
	l.l.Lock() // locks in the color change
	switch l.color {
	case "":
		l.color = {{ index $.LogHasESCColors $key }}.ToESCColor()
	}
	l.println({{ $value }}, iface...)
	l.l.Unlock()
}
{{ else }}
// {{ $key }} is the generated logger function to satisfy the interface
func (l *logger) {{ $key }}(iface ...interface{}) {
	l.l.Lock() // locks in the color change
	switch l.color {
	case "":
		l.color = {{ index $.LogHasESCColors $key }}.ToESCColor()
	}
	l.println({{ $value }}, iface...)
	l.l.Unlock()
}

// {{ $key }}f is the generated logger function to satisfy the interface
func (l *logger) {{ $key }}f(fmt string, iface ...interface{}) {
	l.l.Lock() // locks in the color change
	switch l.color {
	case "":
		l.color = {{ index $.LogHasESCColors $key }}.ToESCColor()
	}
	l.printf({{ $value }}, fmt, iface...)
	l.l.Unlock()
}
{{- end }}
{{- end }}

// Color is the nilLogger function to satisfy the interface. It does nothing.
func (l *nilLogger) Color(x LogColor) Logger { return l }

// NoColor is the nilLogger function to satisfy the interface. It does nothing.
func (l *nilLogger) NoColor() Logger { return l }

// Field is the nilLogger function to satisfy the interface. It does nothing.
func (l *nilLogger) Field(s string, iface interface{}) Logger {
	return l
}

// Fields is the nilLogger function to satisfy the interface. It does nothing.
func (l *nilLogger) Fields(kv ...keyValue) Logger {
	return l
}

// HTTPMiddleware is the nilLogger function to satisfy the interface. It does nothing.
func (l *nilLogger) HTTPMiddleware(next http.Handler) (r http.Handler) {
	return next
}

// OnErr is the nilLogger function to satisfy the interface. It does nothing.
func (l *nilLogger) OnErr(x error) Logger    { return l }

// Suppress is the nilLogger function to satisfy the interface. It does nothing.
func (l *nilLogger) Suppress()               {}

// UnSuppress is the nilLogger function to satisfy the interface. It does nothing.
func (l *nilLogger) UnSuppress()             {}

{{- range $key, $value := .LogLevels }}
{{- $klen := (minus 20 (len $key)) }}{{- $kfmt := printf "%%%ds" $klen }}
{{- $kflen := (minus 7 (len $key)) }}{{- $kffmt := printf "%%%ds" $kflen }}
{{- $klnlen := (minus 6 (len $key)) }}{{- $klnfmt := printf "%%%ds" $klnlen }}

// {{ $key }} is the nilLogger function to satisfy the interface. It does nothing.
func (l *nilLogger) {{ $key }}(iface ...interface{}){{ printf $kfmt "" }}{ return }

// {{ $key }}f is the nilLogger function to satisfy the interface. It does nothing.
func (l *nilLogger) {{ $key }}f(fmt string, iface ...interface{}){{ printf $kffmt "" }}{ return }

// {{ $key }}ln is the nilLogger function to satisfy the interface. It does nothing.
func (l *nilLogger) {{ $key }}ln(iface ...interface{}){{ printf $klnfmt "" }}{ return }
{{- end }}

`))
